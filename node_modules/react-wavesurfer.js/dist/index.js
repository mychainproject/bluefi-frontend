"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const prop_types_1 = __importDefault(require("prop-types"));
const wavesurfer_js_1 = __importDefault(require("wavesurfer.js"));
const helpers_1 = require("./helpers");
const wavesurferParams = new Set([
    "audioContext",
    "audioRate",
    "audioScriptProcessor",
    "autoCenter",
    "autoCenterRate",
    "autoCenterImmediately",
    "backend",
    "backgroundColor",
    "barHeight",
    "barRadius",
    "barGap",
    "barWidth",
    "barMinHeight",
    "closeAudioContext",
    "cursorColor",
    "cursorWidth",
    "drawingContextAttributes",
    "duration",
    "fillParent",
    "forceDecode",
    "height",
    "hideScrollbar",
    "interact",
    "loopSelection",
    "maxCanvasWidth",
    "mediaControls",
    "mediaType",
    "minPxPerSec",
    "normalize",
    "partialRender",
    "pixelRatio",
    "plugins",
    "progressColor",
    "removeMediaElementOnDestroy",
    "renderer",
    "responsive",
    "rtl",
    "scrollParent",
    "skipLength",
    "splitChannels",
    "waveColor",
    "xhr",
]);
const EVENTS = [
    "audioprocess",
    "error",
    "finish",
    "loading",
    "mouseup",
    "pause",
    "play",
    "ready",
    "scroll",
    "seek",
    "zoom",
];
/**
 * Throws an error if the prop is defined and not an integer or not positive
 */
function positiveIntegerProptype(props, propName, componentName) {
    const n = props[propName];
    if (n !== undefined &&
        (typeof n !== "number" ||
            (typeof n === "string" && n !== parseInt(n, 10)) ||
            n < 0)) {
        return new Error(`Invalid ${propName} supplied to ${componentName},
      expected a positive integer`);
    }
    return null;
}
const resizeThrottler = (fn) => () => {
    let resizeTimeout;
    if (!resizeTimeout) {
        // @TODO: Throttle raf
        resizeTimeout = requestAnimationFrame(() => {
            resizeTimeout = null;
            fn();
        });
    }
};
class WavesurferComponent extends react_1.Component {
    constructor(props) {
        super(props);
        this.state = {
            isReady: false,
            pos: 0,
            formattedPos: 0,
        };
        if (typeof wavesurfer_js_1.default === undefined) {
            throw new Error("WaveSurfer is undefined!");
        }
        this.loadMediaElt = this.loadMediaElt.bind(this);
        this.loadAudio = this.loadAudio.bind(this);
        this.seekTo = this.seekTo.bind(this);
        if (this.props.responsive) {
            this.handleResize = resizeThrottler(() => {
                if (!this.wavesurfer)
                    throw new Error("wavesurfer no defined");
                // pause playback for resize operation
                if (this.props.playing) {
                    this.wavesurfer.pause();
                }
                // resize the waveform
                this.wavesurfer.drawBuffer();
                // We allow resize before file isloaded, since we can get wave data from outside,
                // so there might not be a file loaded when resizing
                if (this.state.isReady) {
                    // restore previous position
                    this.seekTo(this.props.pos);
                }
                // restore playback
                if (this.props.playing) {
                    this.wavesurfer.play();
                }
            });
        }
    }
    componentDidMount() {
        if (!this.wavesurferElm)
            throw new Error("Conainer not defined");
        const wavesurferProps = Object.fromEntries(Object.entries(this.props).filter(([key]) => wavesurferParams.has(key)));
        const options = {
            ...wavesurferProps,
            container: this.wavesurferElm,
        };
        this.wavesurfer = wavesurfer_js_1.default.create(options);
        // media element loading is only supported by MediaElement backend
        if (this.props.mediaElt) {
            options.backend = "MediaElement";
        }
        // file was loaded, wave was drawn
        this.wavesurfer.on("ready", () => {
            if (!this.wavesurfer)
                throw new Error("wavesurfer not initialized");
            this.setState({
                isReady: true,
                pos: this.props.pos,
            });
            // set initial position
            if (this.props.pos) {
                this.seekTo(this.props.pos);
            }
            // set initial volume
            if (this.props.volume) {
                this.wavesurfer.setVolume(this.props.volume);
            }
            // set initial playing state
            if (this.props.playing) {
                this.wavesurfer.play();
            }
            // set initial zoom
            if (this.props.zoom) {
                this.wavesurfer.zoom(this.props.zoom);
            }
        });
        this.wavesurfer.on("audioprocess", (pos) => {
            this.setState({
                pos,
            });
            if (this.props.onPositionChange) {
                this.props.onPositionChange({
                    wavesurfer: this.wavesurfer,
                    originalArgs: [pos],
                });
            }
        });
        // `audioprocess` is not fired when seeking, so we have to plug into the
        // `seek` event and calculate the equivalent in seconds (seek event
        // receives a position float 0-1) – See the README.md for explanation why we
        // need this
        this.wavesurfer.on("seek", (pos) => {
            if (this.state.isReady && this.props.onPositionChange) {
                const formattedPos = this.posToSec(pos);
                this.setState({
                    formattedPos,
                });
                this.props.onPositionChange({
                    wavesurfer: this.wavesurfer,
                    originalArgs: [formattedPos],
                });
            }
        });
        // hook up events to callback handlers passed in as props
        EVENTS.forEach((e) => {
            const { wavesurfer } = this;
            const propCallback = this.props[`on${helpers_1.capitaliseFirstLetter(e)}`];
            if (propCallback) {
                if (!this.wavesurfer)
                    throw new Error("wavesurfer not initialized");
                this.wavesurfer.on(e, (...originalArgs) => {
                    propCallback({
                        wavesurfer,
                        originalArgs,
                    });
                });
            }
        });
        // if audioFile prop, load file
        if (this.props.src) {
            this.loadAudio(this.props.src, this.props.audioPeaks);
        }
        // if mediaElt prop, load media Element
        if (this.props.mediaElt) {
            this.loadMediaElt(this.props.mediaElt, this.props.audioPeaks);
        }
        if (this.props.responsive && this.handleResize) {
            window.addEventListener("resize", this.handleResize, false);
        }
    }
    // update wavesurfer rendering manually
    UNSAFE_componentWillReceiveProps(nextProps) {
        if (!this.wavesurfer)
            throw new Error("wavesurfer not initialized");
        let newSource = false;
        let seekToInNewFile;
        // update audioFile
        if (this.props.src !== nextProps.src) {
            this.setState({
                isReady: false,
            });
            this.loadAudio(nextProps.src, nextProps.audioPeaks);
            newSource = true;
        }
        // update mediaElt
        if (nextProps.mediaElt && this.props.mediaElt !== nextProps.mediaElt) {
            this.setState({
                isReady: false,
            });
            this.loadMediaElt(nextProps.mediaElt, nextProps.audioPeaks);
            newSource = true;
        }
        // update peaks
        if (this.props.audioPeaks !== nextProps.audioPeaks) {
            if (nextProps.mediaElt) {
                this.loadMediaElt(nextProps.mediaElt, nextProps.audioPeaks);
            }
            else {
                this.loadAudio(nextProps.src, nextProps.audioPeaks);
            }
        }
        // update position
        if (nextProps.pos !== undefined &&
            this.state.isReady &&
            nextProps.pos !== this.props.pos &&
            nextProps.pos !== this.state.pos) {
            if (newSource) {
                seekToInNewFile = this.wavesurfer.on("ready", () => {
                    this.seekTo(nextProps.pos);
                    seekToInNewFile.un();
                });
            }
            else {
                this.seekTo(nextProps.pos);
            }
        }
        // update playing state
        if (!newSource &&
            (this.props.playing !== nextProps.playing ||
                this.wavesurfer.isPlaying() !== nextProps.playing)) {
            if (nextProps.playing) {
                this.wavesurfer.play();
            }
            else {
                this.wavesurfer.pause();
            }
        }
        // update volume
        if (nextProps.volume && this.props.volume !== nextProps.volume) {
            this.wavesurfer.setVolume(nextProps.volume);
        }
        // update zoom
        if (this.props.zoom !== nextProps.zoom) {
            this.wavesurfer.zoom(nextProps.zoom);
        }
        // update audioRate
        if (nextProps.audioRate && this.props.audioRate !== nextProps.audioRate) {
            this.wavesurfer.setPlaybackRate(nextProps.audioRate);
        }
        // update backgroundColor
        if (nextProps.backgroundColor &&
            this.props.backgroundColor !== nextProps.backgroundColor) {
            this.wavesurfer.setBackgroundColor(nextProps.backgroundColor);
        }
        // update waveColor
        if (nextProps.waveColor && this.props.waveColor !== nextProps.waveColor) {
            this.wavesurfer.setWaveColor(nextProps.waveColor);
        }
        // update progressColor
        if (nextProps.progressColor &&
            this.props.progressColor !== nextProps.progressColor) {
            this.wavesurfer.setProgressColor(nextProps.progressColor);
        }
        if (nextProps.cursorColor &&
            this.props.cursorColor !== nextProps.cursorColor) {
            this.wavesurfer.setCursorColor(nextProps.cursorColor);
        }
        if (nextProps.height && this.props.height !== nextProps.height) {
            this.wavesurfer.setHeight(nextProps.height);
        }
        // turn responsive on
        if (nextProps.responsive &&
            this.props.responsive !== nextProps.responsive &&
            this.handleResize) {
            window.addEventListener("resize", this.handleResize, false);
        }
        // turn responsive off
        if (!nextProps.responsive &&
            this.props.responsive !== nextProps.responsive &&
            this.handleResize) {
            window.removeEventListener("resize", this.handleResize);
        }
    }
    componentWillUnmount() {
        if (!this.wavesurfer)
            throw new Error("wavesurfer not initialized");
        // remove all listeners
        // @ts-ignore TS defs are wrong
        EVENTS.forEach((e) => this.wavesurfer.un(e));
        // destroy wavesurfer instance
        this.wavesurfer.destroy();
        if (this.props.responsive && this.handleResize) {
            window.removeEventListener("resize", this.handleResize);
        }
    }
    // receives seconds and transforms this to the position as a float 0-1
    secToPos(sec) {
        if (!this.wavesurfer)
            throw new Error("wavesurfer not initialized");
        return (1 / this.wavesurfer.getDuration()) * sec;
    }
    // receives position as a float 0-1 and transforms this to seconds
    posToSec(pos) {
        if (!this.wavesurfer)
            throw new Error("wavesurfer not initialized");
        return pos * this.wavesurfer.getDuration();
    }
    // pos is in seconds, the 0-1 proportional position we calculate here …
    seekTo(sec) {
        if (!this.wavesurfer)
            throw new Error("wavesurfer not initialized");
        const pos = this.secToPos(sec);
        if (this.props.autoCenter) {
            this.wavesurfer.seekAndCenter(pos);
        }
        else {
            this.wavesurfer.seekTo(pos);
        }
    }
    // load a media element selector or HTML element
    // if selector, get the HTML element for it
    // and pass to _loadAudio
    loadMediaElt(selectorOrElt, audioPeaks) {
        if (selectorOrElt instanceof window.HTMLElement) {
            this.loadAudio(selectorOrElt, audioPeaks);
        }
        else {
            const elm = document.querySelector(selectorOrElt);
            if (!elm) {
                throw new Error("Media Element not found!");
            }
            this.loadAudio(elm, audioPeaks);
        }
    }
    // pass audio data to wavesurfer
    loadAudio(audioFileOrElt, audioPeaks) {
        if (!this.wavesurfer)
            throw new Error("wavesurfer not initialized");
        if (audioFileOrElt instanceof window.HTMLElement) {
            // media element
            this.wavesurfer.loadMediaElement(audioFileOrElt, audioPeaks);
        }
        else if (typeof audioFileOrElt === "string") {
            // bog-standard string is handled by load method and ajax call
            this.wavesurfer.load(audioFileOrElt, audioPeaks);
        }
        else if (audioFileOrElt instanceof window.Blob) {
            // blob or file is loaded with loadBlob method
            this.wavesurfer.loadBlob(audioFileOrElt);
        }
        else {
            throw new Error(`Wavesurfer.loadAudio expects prop audioFile
        to be either HTMLElement, string or file/blob`);
        }
    }
    render() {
        const childrenWithProps = this.props.children
            ? react_1.default.Children.map(this.props.children, (child) => react_1.default.cloneElement(child, {
                wavesurfer: this.wavesurfer,
                isReady: this.state.isReady,
            }))
            : false;
        return (react_1.default.createElement("div", null,
            react_1.default.createElement("div", { ref: (c) => {
                    this.wavesurferElm = c || undefined;
                } }),
            childrenWithProps));
    }
}
exports.default = WavesurferComponent;
WavesurferComponent.defaultProps = {
    playing: false,
    pos: 0,
    responsive: true,
    autoCenter: true,
    onPositionChange: () => { },
};
WavesurferComponent.propTypes = {
    playing: prop_types_1.default.bool,
    pos: prop_types_1.default.number,
    src: (props, propName, componentName) => {
        const prop = props[propName];
        if (prop &&
            typeof prop !== "string" &&
            !(prop instanceof window.Blob) &&
            !(prop instanceof window.File)) {
            return new Error(`Invalid ${propName} supplied to ${componentName}
          expected either string or file/blob`);
        }
        return null;
    },
    mediaElt: prop_types_1.default.oneOfType([
        prop_types_1.default.string,
        prop_types_1.default.instanceOf(window.HTMLElement),
    ]),
    audioPeaks: prop_types_1.default.array,
    volume: prop_types_1.default.number,
    zoom: prop_types_1.default.number,
    responsive: prop_types_1.default.bool,
    onPositionChange: prop_types_1.default.func,
    children: prop_types_1.default.oneOfType([prop_types_1.default.element, prop_types_1.default.array]),
    audioRate: prop_types_1.default.number,
    backend: prop_types_1.default.oneOf(["WebAudio", "MediaElement"]),
    barWidth: (props, propName, componentName) => {
        const prop = props[propName];
        if (prop !== undefined && typeof prop !== "number") {
            return new Error(`Invalid ${propName} supplied to ${componentName}
          expected either undefined or number`);
        }
        return null;
    },
    cursorColor: prop_types_1.default.string,
    // @ts-ignore
    cursorWidth: positiveIntegerProptype,
    dragSelection: prop_types_1.default.bool,
    fillParent: prop_types_1.default.bool,
    // @ts-ignore
    height: positiveIntegerProptype,
    hideScrollbar: prop_types_1.default.bool,
    interact: prop_types_1.default.bool,
    loopSelection: prop_types_1.default.bool,
    mediaControls: prop_types_1.default.bool,
    // @ts-ignore
    minPxPerSec: positiveIntegerProptype,
    normalize: prop_types_1.default.bool,
    pixelRatio: prop_types_1.default.number,
    progressColor: prop_types_1.default.string,
    scrollParent: prop_types_1.default.bool,
    skipLength: prop_types_1.default.number,
    waveColor: prop_types_1.default.oneOfType([
        prop_types_1.default.string,
        prop_types_1.default.instanceOf(window.CanvasGradient),
    ]),
    autoCenter: prop_types_1.default.bool,
};
//# sourceMappingURL=index.js.map